import{_ as F}from"./ppr-B2tdxrPG.js";import"./modulepreload-polyfill-B5Qt9EMX.js";const j=""+new URL("assets/pdf.worker.min-CXgfMxHN.mjs",import.meta.url).href,S=1500,U="Timed out waiting for image object",M="PPRDATA:";var T,v;const L=!!((v=(T=import.meta)==null?void 0:T.env)!=null&&v.DEV);function E(...a){L&&console.log(...a)}async function N(a,c,O=S){let w;const u=new Promise((i,r)=>{w=setTimeout(()=>r(new Error(`Timed out waiting for image object ${c}`)),O)}),s=new Promise(i=>{let r=!1;const d=y=>{r||(r=!0,i(y))},h=a.objs.get(c,d);h&&d(h)});return Promise.race([s,u]).finally(()=>clearTimeout(w))}function W(a){return a instanceof Error&&typeof a.message=="string"&&a.message.startsWith(U)}function C(a){if(typeof a!="string")return null;const c=a.trim();return c.startsWith(M)?c.slice(M.length):null}function $(a){console.warn("Skipping image during extraction:",a)}async function X(a,c,O,w={}){const{allowRenderRetry:u=!0,timeout:s=S}=w;let i=!1;for(;;)try{return await N(a,c,s)}catch(r){if(!W(r))throw r;if(!(u&&!i)){const h=i?"Timed out waiting for image data after rendering":"Timed out waiting for image data";throw $({stage:"final-timeout",imageName:c,attemptedRender:i,allowRenderRetry:u,timeout:s}),new Error(h)}E(`Image ${c} timed out, rendering page and retrying...`),await O(),i=!0}}async function K(){const a=await F(()=>import("./pdf-D1uDTcfQ.js"),[],import.meta.url);a.GlobalWorkerOptions.workerSrc=j;function c(u){try{const s=atob(u),i=new Uint8Array(s.length);for(let r=0;r<s.length;r++)i[r]=s.charCodeAt(r);return new TextDecoder().decode(i)}catch(s){return console.warn("Failed to decode embedded PPR data",s),null}}async function O(u,{onProgress:s}={}){E("Starting image extraction from PDF...");const i=await a.getDocument({data:u}).promise;E("PDF loaded, pages:",i.numPages);const r=[],d=[],h=[],y=new Map,f=[];for(let o=1;o<=i.numPages;o++){s&&await s({page:o,totalPages:i.numPages});const P=await i.getPage(o);let D=!1;const R=async()=>{if(D)return;const l=P.getViewport({scale:1}),I=document.createElement("canvas"),p=I.getContext("2d");I.width=l.width,I.height=l.height,await P.render({canvasContext:p,viewport:l}).promise,D=!0},x=await P.getOperatorList();E(`Page ${o}: ${x.fnArray.length} operators (images? ${x.fnArray.filter(l=>l===a.OPS.paintImageXObject||l===a.OPS.paintInlineImageXObject).length})`);for(let l=0;l<x.fnArray.length;l++){const I=x.fnArray[l],p=x.argsArray[l],b=I===a.OPS.paintImageXObject,A=I===a.OPS.paintInlineImageXObject;if(!(!b&&!A))try{let e,t=null;if(b){t=p==null?void 0:p[0],E(`Found xobject image operator: ${t}`);try{e=await X(P,t,R,{allowRenderRetry:!D})}catch(m){const k={page:o,imageName:t,reason:(m==null?void 0:m.message)||"Timed out waiting for image data"};f.push(k),$(k);continue}}else e=p==null?void 0:p[0],t=`inline-${o}-${l}`,E(`Found inline image operator: ${t}`);if(!e||!e.width||!e.height){const m={page:o,imageName:t,reason:"Missing image dimensions"};f.push(m),$(m);continue}const n=document.createElement("canvas");n.width=e.width,n.height=e.height;const g=n.getContext("2d"),_=(()=>{if(e.data){const m=g.createImageData(e.width,e.height);return m.data.set(e.data),g.putImageData(m,0,0),n.toDataURL("image/png")}return e.bitmap?(g.drawImage(e.bitmap,0,0),n.toDataURL("image/png")):null})();if(_){r.push(_),d.push(t);const m=(y.get(o)||0)+1;y.set(o,m),h.push({name:t,page:o,order:m}),E(`Extracted image ${r.length}`)}else{const m={page:o,imageName:t,reason:"Unsupported image payload"};f.push(m),$(m)}}catch(e){console.warn("Failed to extract image:",e)}}}return E(`Image extraction complete. Total images extracted: ${r.length}. Skipped: ${f.length}`),{images:r,imageNames:d,imagePlacements:h,skippedImages:f}}async function w(u){const s=await a.getDocument({data:u}).promise;try{const i=await s.getMetadata().catch(()=>null),r=i==null?void 0:i.info,d=i==null?void 0:i.metadata,h=r&&typeof r.Keywords=="string"&&r.Keywords||r&&typeof r.keywords=="string"&&r.keywords||null,y=C(h),f=r&&typeof r.PprData=="string"&&r.PprData||(d&&typeof d.get=="function"?d.get("PprData"):null)||y;if(!f||typeof f!="string")return null;const o=c(f);return typeof o=="string"?o:null}finally{s&&typeof s.destroy=="function"&&s.destroy()}}return{decodeFromPdf:c,extractImagesFromPdf:O,readEmbeddedPprData:w}}function H({metadata:a,extractedImages:c,extractedPlacements:O=[],skippedImages:w=[],segmentCount:u=4}){if(!a)throw new Error("Metadata is required to reconstruct PPR data");const s=a.segments||{},i=Object.values(s).reduce((e,t)=>{const n=typeof t=="number"?t:parseInt(t,10);return e+(Number.isFinite(n)?n:0)},0),r=Array.isArray(a.imageManifest)&&a.imageManifest.length===i?a.imageManifest:null,d=[];for(let e=1;e<=u;e++){const t=Number(s[e])||0;for(let n=0;n<t;n++)d.push({alias:`seg${e}-img${n+1}`,segment:e})}const h=r&&r.length?r:d,y=new Map;h.forEach(({alias:e,segment:t})=>{y.set(e,{segment:t})});const f=Array.isArray(a.imagePlacements)&&a.imagePlacements.length>0;f&&a.imagePlacements.forEach(({alias:e,page:t,order:n})=>{y.set(e,{...y.get(e),page:t,order:n})});const o={studentName:a.studentName||"",images:{}},P=new Set(c.map((e,t)=>t)),D=new Map;f&&O.forEach(({page:e,order:t,index:n})=>{if(!Number.isInteger(n))return;const g=`${e}:${t}`;D.has(g)||D.set(g,[]),D.get(g).push(n)});const R=[],x=e=>{const t=D.get(e);if(!t||!t.length)return null;const n=t.shift();return P.delete(n),n},l=()=>{const e=P.values().next();return e.done?null:(P.delete(e.value),e.value)};let I=!1;h.forEach(({alias:e,segment:t})=>{o.images[t]||(o.images[t]=[]);const n=y.get(e);let g=null;n!=null&&n.page&&(n!=null&&n.order)&&(g=x(`${n.page}:${n.order}`)),g===null&&(g=l(),g!==null&&(I=!0)),g!==null&&typeof c[g]=="string"&&o.images[t].push(c[g])});for(let e=1;e<=u;e++){const t=Number(s[e])||0;o.images[e]||(o.images[e]=[]);const n=o.images[e].length;n<t&&R.push({segment:e,expected:t,received:n})}const p=P.size,b=[],A=[];if(R.length){const e=R.map(({segment:t,expected:n,received:g})=>`Segment ${t} (${n-g} missing)`).join("; ");b.push(`Some images could not be recovered: ${e}. Please re-add them manually.`),A.push(...R.map(({segment:t})=>t))}return f&&I&&b.push("Extra images were found in the PDF metadata that could not be matched exactly. They were assigned based on remaining space; please verify each segment."),w.length&&b.push(`${w.length} image(s) could not be decoded from the PDF in time. Highlighted segments may be incomplete.`),p>0&&b.push(`${p} unreferenced image(s) were ignored during reconstruction.`),b.length&&console.warn("Image reconstruction mismatch:",{expectedImageTotal:i,extractedImages:c.length,missingImagesBySegment:R,leftoverImages:p,skippedImages:w}),{workspaceData:o,notices:b,missingImages:R,segmentsWithMissingImages:[...new Set(A)],leftoverImagesCount:p}}export{K as createPdfLoader,H as reconstructPprDataFromPdf};
